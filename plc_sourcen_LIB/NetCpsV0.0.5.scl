DATA_BLOCK "CPSbuffer"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
NON_RETAIN
   VAR 
      HEADERlengthByte : Int;
      frames_rcv : Int;
      ToInterprete : Struct
         frame : "UDT_CPSFrame";
         frame_res : "UDT_CPSFrame";
         overflow : Int;
         enabled : Bool;
         aktor_index : Int;
         "counter" : Int;
      END_STRUCT;
      ToSend : Struct
         frame : "UDT_CPSFrame";
         frame_res : "UDT_CPSFrame";
         overflow : Int;
         enabled : Bool;
         "counter" : Int;
      END_STRUCT;
      ibs_val : "UDT_CPSFrame";
   END_VAR


BEGIN
   HEADERlengthByte := 6;

END_DATA_BLOCK

FUNCTION "CPStoSend" : Void
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      frameToSend : "UDT_CPSFrame";
   END_VAR

   VAR_TEMP 
      loopData : Int;
      hitCounter : Int;
   END_VAR


BEGIN
	
	
	IF NOT "CPSbuffer".ToSend.enabled THEN
	    "CPSbuffer".ToSend.frame := #frameToSend;
	    "CPSbuffer".ToSend.enabled := TRUE;
	    
	    "CPSbuffer".ToSend.counter := "CPSbuffer".ToSend.counter + 1;
	    
	    //look in frame: 10x following content of 0 -> frame end
	    #loopData := 0;
	    #hitCounter := 0;
	    WHILE #hitCounter < 10 DO
	        
	        //0 value counter 
	        IF #frameToSend.data[#loopData] = 0 THEN
	            #hitCounter := #hitCounter + 1;
	        ELSE
	            #hitCounter := 0;
	        END_IF;
	        
	        //Ende Kennung -> -1
	        IF #frameToSend.data[#loopData] = -1 THEN
	            #loopData := #loopData + 10; //wegen abzug im nächsten schritt
	            EXIT;
	            //#hitCounter := 10; //schleifen abbruch erzwingen
	        END_IF;
	        
	        #loopData := #loopData + 1;
	    END_WHILE;
	    
	    "CPSbuffer".ToSend.frame.frame_length := INT_TO_UINT(#loopData * 2 + "CPSbuffer".HEADERlengthByte - 20); //*2 wegen int to byte; +6 wegen header length; -20 wegen reserve vergleichs 0en
	    
	
	ELSE
	    "CPSbuffer".ToSend.frame_res := #frameToSend;
	    "CPSbuffer".ToSend.overflow := "CPSbuffer".ToInterprete.overflow + 1;
	END_IF;
END_FUNCTION

DATA_BLOCK "remoteValues"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
NON_RETAIN
   VAR 
      used_vars : Int;
      "var" : Array[0..20] of "UDT_sensor_value";
   END_VAR


BEGIN
   used_vars := 10;
   "var"[0].exponent := 10;
   "var"[1].exponent := 10;
   "var"[2].exponent := 10;
   "var"[3].exponent := 10;
   "var"[4].exponent := 10;
   "var"[5].exponent := 10;
   "var"[6].exponent := 10;
   "var"[7].exponent := 10;
   "var"[8].exponent := 10;
   "var"[9].exponent := 10;
   "var"[11].exponent := 100;
   "var"[12].exponent := 100;
   "var"[13].exponent := 100;
   "var"[14].exponent := 100;
   "var"[15].exponent := 100;
   "var"[16].exponent := 100;

END_DATA_BLOCK

FUNCTION "CPSisReq" : Bool
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      index : Int;
   END_VAR

   VAR_IN_OUT 
      frame : "UDT_CPSFrame";
   END_VAR

   VAR_TEMP 
      loopFrames : Int;
      loopData : Int;
      tmp_stat : Int;
   END_VAR


BEGIN
	#CPSisReq := FALSE;
	
	IF "CPSbuffer".ToInterprete.enabled THEN
	    IF "CPSbuffer".ToInterprete.aktor_index = #index THEN
	        #CPSisReq := TRUE;
	        #frame := "CPSbuffer".ToInterprete.frame;
	        "CPSbuffer".ToInterprete.enabled := FALSE;
	    END_IF;
	END_IF;
	
	
	
END_FUNCTION

DATA_BLOCK "localValues"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
NON_RETAIN
   VAR 
      "var" : Array[0..20] of "UDT_sensor_value";
   END_VAR


BEGIN
   "var"[0].exponent := 10;
   "var"[1].exponent := 10;
   "var"[2].exponent := 10;
   "var"[3].exponent := 10;
   "var"[4].exponent := 10;
   "var"[5].exponent := 10;
   "var"[6].exponent := 10;
   "var"[7].exponent := 10;
   "var"[8].exponent := 10;
   "var"[9].exponent := 10;
   "var"[11].exponent := 100;
   "var"[12].exponent := 100;
   "var"[13].exponent := 100;
   "var"[14].exponent := 100;
   "var"[15].exponent := 100;
   "var"[16].exponent := 100;

END_DATA_BLOCK

FUNCTION_BLOCK "NetPlc"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      remoteIP4okted : USInt;
   END_VAR

   VAR 
      frame_counter : Int;
      timerSendInterval : Time := T#1S;
      pulseTimer {OriginalPartName := 'IEC_TIMER'; LibVersion := '1.0'} : TP_TIME;
      pulseDone : Bool;
      mem_pulseTimer : Bool;
   END_VAR

   VAR_TEMP 
      tmp_int : Int;
      new_pulse : Bool;
      frame : "UDT_CPSFrame";
   END_VAR

   VAR CONSTANT 
      HEADER_PLCdata : Byte := 2#100000;   // Prozesswerte zwischen PLC austauschen
   END_VAR


BEGIN
	//TODO: in static bereich verschieben
	#frame.remote_addr.REM_IP_ADDR[1] := 192;
	#frame.remote_addr.REM_IP_ADDR[2] := 168;
	#frame.remote_addr.REM_IP_ADDR[3] := 1;
	#frame.remote_addr.REM_IP_ADDR[4] := #remoteIP4okted; //OG 201; EG 202; parport 203; IBS 205
	#frame.remote_addr.REM_PORT_NR := 2202; //"Local" Port of Server Job
	#frame.FrameIndex := #frame_counter;
	#frame.HeaderFlags := #HEADER_PLCdata;
	#frame.resI := 11;
	#frame.resII := 11;
	#frame.frame_length := INT_TO_UINT("remoteValues".used_vars * 3);
	
	//sende intervall bestimmen
	#pulseTimer(IN:=#new_pulse,
	            PT:=#timerSendInterval);
	#new_pulse := FALSE;
	
	#pulseDone := NOT #pulseTimer.Q AND #mem_pulseTimer; //fallende flanke an pulseTimer ausgang
	#mem_pulseTimer := #pulseTimer.Q;
	
	
	//frame für versand zusammenbauen
	IF #pulseDone THEN
	    #new_pulse := TRUE;
	    
	    #frame_counter := #frame_counter + 1;
	    
	    FOR #tmp_int := 0 TO UINT_TO_INT(#frame.frame_length) DO
	        #frame.data[(#tmp_int) * 3] := #tmp_int; //index des values
	        #frame.data[((#tmp_int) * 3) + 1] := "remoteValues".var[#tmp_int].value;
	        #frame.data[((#tmp_int) * 3) + 2] := "remoteValues".var[#tmp_int].exponent;
	    END_FOR;
	    
	    
	    //ende kennung hinzufügen                                        //-1 nur netto daten; /2 da int und nicht byte; *3 für drei daten je sensor wert; +2 für MngData Type und letzter platz +1
	    #frame.data[(UINT_TO_INT(#frame.frame_length) + 1)] := -1;
	    
	    //von int auf byte basis verdoppeln
	    #frame.frame_length := #frame.frame_length * 2 + INT_TO_UINT("CPSbuffer".HEADERlengthByte);
	    
	    //frame in sendepuffer legen
	    "CPStoSend"(#frame);
	END_IF;
	
	
	
END_FUNCTION_BLOCK

FUNCTION "CPSnewReq" : Void
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      frameToInterprete : "UDT_CPSFrame";
   END_VAR


BEGIN
	
	
	IF NOT "CPSbuffer".ToInterprete.enabled THEN
	    "CPSbuffer".ToInterprete.frame := #frameToInterprete;
	    "CPSbuffer".ToInterprete.enabled := TRUE;
	    "CPSbuffer".ToInterprete.aktor_index := #frameToInterprete.data[0]; //erste stelle in daten ist interface ID des aktors
	ELSE
	    "CPSbuffer".ToInterprete.frame_res := "CPSbuffer".ToInterprete.frame; //verschieben des nicht interpretierbaren frames in res
	    "CPSbuffer".ToInterprete.frame := #frameToInterprete;
	    "CPSbuffer".ToInterprete.overflow := "CPSbuffer".ToInterprete.overflow + 1;
	END_IF;
END_FUNCTION

FUNCTION "CPSinterpreteMngData" : Void
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_IN_OUT 
      tmp_RCVdataINT : "UDT_CPSFrame";
   END_VAR

   VAR_TEMP 
      tmp_dtl {OriginalPartName := 'DTL'; LibVersion := '1.0'} : DTL;
      tmp_int : Int;
      tmp_FrameCopy : "UDT_CPSFrame";
      tmp_sensorval : "UDT_sensor_value";
   END_VAR


BEGIN
	
	CASE (#tmp_RCVdataINT.data[0]) OF
	    1:  // read local system time
	        #tmp_int := RD_LOC_T(#tmp_dtl);
	        
	        #tmp_RCVdataINT.data[1] := UINT_TO_INT(#tmp_dtl.YEAR);
	        #tmp_RCVdataINT.data[2] := UINT_TO_INT(#tmp_dtl.MONTH);
	        #tmp_RCVdataINT.data[3] := UINT_TO_INT(#tmp_dtl.DAY);
	        #tmp_RCVdataINT.data[4] := UINT_TO_INT(#tmp_dtl.HOUR);
	        #tmp_RCVdataINT.data[5] := UINT_TO_INT(#tmp_dtl.MINUTE);
	        #tmp_RCVdataINT.data[6] := UINT_TO_INT(#tmp_dtl.SECOND);
	        #tmp_RCVdataINT.data[7] := -1;
	        
	    2:  // set local system time
	        #tmp_dtl := DTL#1970-01-01-00:00:00.0;
	        #tmp_dtl.YEAR := INT_TO_UINT(#tmp_RCVdataINT.data[1]);
	        #tmp_dtl.MONTH := INT_TO_USINT(#tmp_RCVdataINT.data[2]);
	        #tmp_dtl.DAY := INT_TO_USINT(#tmp_RCVdataINT.data[3]);
	        #tmp_dtl.HOUR := INT_TO_USINT(#tmp_RCVdataINT.data[4]) - 1; //Sommer-/Winter Zeit, Zeitzonen Problematik
	        #tmp_dtl.MINUTE := INT_TO_USINT(#tmp_RCVdataINT.data[5]);
	        #tmp_dtl.SECOND := INT_TO_USINT(#tmp_RCVdataINT.data[6]);
	        #tmp_dtl.NANOSECOND := 0;
	        
	        #tmp_int := WR_SYS_T(#tmp_dtl);
	        #tmp_RCVdataINT.data[1] := #tmp_int; //return result to function: write time
	        #tmp_RCVdataINT.data[2] := -1;
	        
	    3:  // DBG
	        #tmp_RCVdataINT.data[1] := 1;
	        #tmp_RCVdataINT.data[9] := -1;
	        
	    10: //sensor data -> TODO: change to ProzessIO Data
	        //read requested values from DB "localValues" and send them back to remote client
	        #tmp_FrameCopy := #tmp_RCVdataINT;
	        #tmp_RCVdataINT.data[0] := 10; //überflüssig, sollte sowieso drinnen stehen
	        #tmp_RCVdataINT.data[1] := 0;
	        #tmp_RCVdataINT.data[2] := 0;
	        //+1 da in erstem index Type of MngData steht
	        FOR #tmp_int := 1 TO UINT_TO_INT( #tmp_RCVdataINT.frame_length +1 ) - "CPSbuffer".HEADERlengthByte DO
	            #tmp_sensorval := "localValues".var[#tmp_FrameCopy.data[#tmp_int]]; 
	            #tmp_RCVdataINT.data[(#tmp_int ) * 3]  := #tmp_FrameCopy.data[#tmp_int];
	            #tmp_RCVdataINT.data[((#tmp_int ) * 3) + 1] := #tmp_sensorval.value;
	            #tmp_RCVdataINT.data[((#tmp_int ) * 3) + 2] := #tmp_sensorval.exponent;
	        END_FOR;
	        
	        //ende kennung hinzufügen                                        //-1 nur netto daten; /2 da int und nicht byte; *3 für drei daten je sensor wert; +2 für MngData Type und letzter platz +1
	        #tmp_RCVdataINT.data[ ((UINT_TO_INT( #tmp_RCVdataINT.frame_length) - "CPSbuffer".HEADERlengthByte -1)/2 * 3 ) +3 ] := -1;
	
	    11: //receive values from remote plc
	        ;
	    ELSE  // Statement section ELSE
	        ;
	END_CASE;
	"CPStoSend"(#tmp_RCVdataINT);
	(*
	        #NET_GET_WEATHER:
	            #net.data.data[0] := REAL_TO_INT("weather_temperatur" * 100);
	            #net.data.data[1] := "weather_sun_south(klux)";
	            #net.data.data[2] := "weather_sun_west(klux)";
	            #net.data.data[3] := "weather_sun_east(klux)";
	            #net.data.data[4] := "weather_light(lux)";
	            #net.data.data[5] := REAL_TO_INT("weather_wind(m/s)" * 100);
	            #net.data.data[6] := BOOL_TO_INT("weather_rain");
	            #net.data.data[7] := "sense_lux_stairs_og";
	            #net.data.data[8] := REAL_TO_INT("sense_temperature_stairs_og" * 100);
	            #net.data.data[9] := REAL_TO_INT("sense_temperature_floor_ug" * 100);
	            #net.data.data[10] := REAL_TO_INT("sense_humidity_floor_ug" * 100);
	*)
END_FUNCTION

FUNCTION_BLOCK "iCPS"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      port_remote : UInt;
      port_listen : UInt;
   END_VAR

   VAR 
      SENDstate : Int;
      SENDTCON {OriginalPartName := 'T_CON'; LibVersion := '3.0'} : TCON;
      SENDconn {OriginalPartName := 'TCON_Param'; LibVersion := '1.0'} : TCON_Param;
      SENDTUSEND {OriginalPartName := 'T_SEND'; LibVersion := '3.0'} : TUSEND;
   END_VAR
   VAR DB_SPECIFIC
      SENDdata : "UDT_CPSFrame";   // important to set var retain (remanent)
   END_VAR
   VAR 
      RCVTCON {OriginalPartName := 'T_CON'; LibVersion := '3.0'} : TCON;
      RCVTURCV {OriginalPartName := 'T_RCV'; LibVersion := '3.0'} : TURCV;
      RCVconn {OriginalPartName := 'TCON_Param'; LibVersion := '1.0'} : TCON_Param;
      RCVstate : Int;
   END_VAR
   VAR DB_SPECIFIC
      RCVdata : "UDT_CPSFrameByte";
      RCVdataINT { S7_HMI_Accessible := 'False'; S7_HMI_Visible := 'False'} AT RCVdata : Array[0..258] of Int;
   END_VAR
   VAR 
      SendLocalValues : "NetPlc";
   END_VAR

   VAR_TEMP 
      tmp_count : Int;
      tmp_dtl {OriginalPartName := 'DTL'; LibVersion := '1.0'} : DTL;
      tmp_int_array : Array[0..15] of Int;
      tmp_RCVdataINT : "UDT_CPSFrame";
      tmp_loop : Int;
   END_VAR

   VAR CONSTANT 
      INIT : Int := 0;
      WORKING : Int := 1;
      portSend : UInt := 2204;
      portRcv : UInt := 2202;
      CONNSEND_ID : CONN_OUC := 1;
      CONNRCV_ID : CONN_OUC := 2;
      HEADER_container : Byte := 2#1;
      HEADER_SYNC : Byte := 2#10;
      HEADER_unused : Byte := 2#100;
      HEADER_ACKN : Byte := 2#1000;   // acknowledge
      HEADER_PdataIO : Byte := 2#10000;   // Prozessdata IOs
      HEADER_PLCdata : Byte := 2#100000;   // Prozesswerte zwischen PLC austauschen
      HEADER_MngData : Byte := 2#1000000;   // CPU Management Data
   END_VAR


BEGIN
	//#################### not generic jet ###################
	//#SendLocalValues(205); //could also be called in Main
	
	//+++++++++++++++++++++++++++++++++++++++ SEND +++++++++++++++++++++++++++++++++++++
	CASE #SENDstate OF
	    #INIT:
	        #SENDconn.ID := #CONNSEND_ID;
	        #SENDconn.CONNECTION_TYPE := 19;
	        #SENDconn.ACTIVE_EST := FALSE;
	        #SENDconn.LOCAL_TSAP_ID_LEN := 2;
	        #SENDconn.REM_STADDR_LEN := 0;
	        #SENDconn.REM_TSAP_ID_LEN := 0;
	      
	        #SENDconn.LOCAL_TSAP_ID[1] := UINT_TO_BYTE(#portSend / 256);
	        #SENDconn.LOCAL_TSAP_ID[2] := UINT_TO_BYTE(#portSend MOD 256);
	        #SENDTCON.REQ := TRUE;
	        
	        IF #SENDTCON.DONE THEN
	          #SENDTCON.REQ := FALSE;
	          #SENDstate := #WORKING;
	        END_IF;
	        IF #SENDTCON.ERROR THEN
	          #SENDTCON.REQ := FALSE;
	        END_IF;
	    
	    #WORKING:
	
	        IF NOT #SENDTUSEND.BUSY THEN
	            //check if buffer (local var AND CPSbuffer DB var) contains frames to send
	            IF "CPSbuffer".ToSend.enabled THEN
	                #SENDTUSEND.REQ := TRUE;
	                "CPSbuffer".ToSend.enabled := FALSE;
	                #SENDdata := "CPSbuffer".ToSend.frame;
	                
	                //if input port_remote == 0 use default port 50000
	                IF #port_remote = 0 THEN
	                    #SENDdata.remote_addr.REM_PORT_NR := 50000;
	                ELSE
	                    #SENDdata.remote_addr.REM_PORT_NR := #port_remote; //TODO: port in SYNC frame von client mitliefern    
	                END_IF;
	                
	                #SENDdata.StructVersion := 1;
	                #SENDdata.resI := 16#af;
	                #SENDdata.resII := 16#fe;
	            END_IF;
	        ELSE
	            #SENDTUSEND.REQ := FALSE;
	        END_IF;
	END_CASE;
	(*
	IF #SENDTUSEND.DONE THEN
	  #SENDTUSEND.REQ := FALSE;
	END_IF;
	IF #SENDTUSEND.ERROR THEN
	  #SENDTUSEND.REQ := FALSE;
	END_IF;
	*)
	
	//+++++++++++++++++++++++++++++++++++++++ RCV +++++++++++++++++++++++++++++++++++++
	CASE #RCVstate OF
	    #INIT:
	    #RCVTCON.REQ := TRUE;
	    
	    #RCVconn.ID := #CONNRCV_ID;
	    #RCVconn.CONNECTION_TYPE := 19;
	    #RCVconn.ACTIVE_EST := FALSE;
	    #RCVconn.LOCAL_TSAP_ID_LEN := 2;
	    #RCVconn.REM_STADDR_LEN := 0;
	    #RCVconn.REM_TSAP_ID_LEN := 0;
	    
	    //if input #port_listen == 0 use default server port 2202 
	    IF #port_listen = 0 THEN
	        #RCVconn.LOCAL_TSAP_ID[1] := UINT_TO_BYTE(#portRcv / 256);
	        #RCVconn.LOCAL_TSAP_ID[2] := UINT_TO_BYTE(#portRcv MOD 256);
	    ELSE
	        #RCVconn.LOCAL_TSAP_ID[1] := UINT_TO_BYTE(#port_listen / 256);
	        #RCVconn.LOCAL_TSAP_ID[2] := UINT_TO_BYTE(#port_listen MOD 256);
	    END_IF;
	    #RCVconn.ACTIVE_EST := FALSE;
	    
	    IF #RCVTCON.DONE THEN
	      #RCVTCON.REQ := FALSE;
	      #RCVstate := #WORKING;
	    END_IF;
	    IF #RCVTCON.ERROR THEN
	      #RCVTCON.REQ := FALSE;
	    END_IF;
	    
	#WORKING:
	    (*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	    +++++++++++++++++++++++++++++++++++++++ interprete +++++++++++++++++++++++++++++++++++++
	    +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*)
	    IF #RCVTURCV.NDR THEN
	        "CPSbuffer".frames_rcv := "CPSbuffer".frames_rcv + 1;
	          IF #RCVdata.StructVersion = 1 THEN
	              
	              //umkopieren notwendig damit daten als INT und nicht als Byte[] verarbeitet werden können
	              #tmp_RCVdataINT.remote_addr := #RCVdata.remote_addr;
	              #tmp_RCVdataINT.StructVersion := #RCVdata.StructVersion;
	              #tmp_RCVdataINT.HeaderFlags := #RCVdata.HeaderFlags;
	              #tmp_RCVdataINT.FrameIndex := #RCVdata.FrameIndex;
	              #tmp_RCVdataINT.frame_length := #RCVdata.frame_length;
	              
	              //hier wird nur der empfangene teil umkopiert -> nicht kopierter bereich hat zufallsdaten
	              //FOR #tmp_loop := 0 TO UINT_TO_INT(255) DO
	              FOR #tmp_loop := 0 TO UINT_TO_INT(#RCVdata.frame_length) - "CPSbuffer".HEADERlengthByte DO
	                  #tmp_RCVdataINT.data[#tmp_loop] := #RCVdataINT[#tmp_loop + 3];
	              END_FOR;
	              
	            //### SYNC ### -> Empfangenes packet spiegeln und wieder zurück senden
	              IF (#tmp_RCVdataINT.HeaderFlags AND #HEADER_SYNC) <> 0 THEN
	                  //#tmp_RCVdataINT.frame_length := INT_TO_UINT("CPSBuffer".HEADERlengthByte); //payload wird abgeschnitten und nur header (6 byte) gesendet
	                  //"CPSsendPUT"(#tmp_RCVdataINT);
	                  #tmp_RCVdataINT.data[0] := -1;
	                  "CPStoSend"(#tmp_RCVdataINT);
	            END_IF;
	            //### not used ###
	            
	            //### acknowledge ### -> MIRROR FRAME and send back
	            IF (#tmp_RCVdataINT.HeaderFlags AND #HEADER_ACKN) <> 0 THEN
	                "CPStoSend"(#tmp_RCVdataINT);
	            END_IF;
	            
	            //### ProcessData_value ###
	            IF (#tmp_RCVdataINT.HeaderFlags AND #HEADER_PdataIO) <> 0 THEN
	                //"CPSworkPUT"(#tmp_RCVdataINT);
	                "CPSnewReq"(#tmp_RCVdataINT);
	            END_IF;
	            
	            //### ProcessData_param ###
	            IF (#RCVdata.HeaderFlags AND #HEADER_PLCdata) <> 0 THEN
	                FOR #tmp_count := 0 TO UINT_TO_INT(#tmp_RCVdataINT.frame_length) - "CPSbuffer".HEADERlengthByte BY +2 DO
	                    "remoteValues".var[#tmp_RCVdataINT.data[#tmp_count]].value := #tmp_RCVdataINT.data[#tmp_count + 1];
	                END_FOR;
	            END_IF;
	            
	            //### ManagementData ###
	            IF (#tmp_RCVdataINT.HeaderFlags AND #HEADER_MngData) <> 0 THEN
	                "CPSbuffer".ToInterprete.counter := "CPSbuffer".ToInterprete.counter + 1;
	                "CPSinterpreteMngData"(#tmp_RCVdataINT);
	                //"CPStoSend"(#tmp_RCVdataINT);
	            END_IF;
	            
	            
	            (*  //wahrscheinlich wird es dieses bit nur von PLC zu PC geben
	IF (#RCVdata.HeaderFlags AND 2#100) <> 0 THEN
	    ;// LogMessage
	END_IF;
	            *)
	            
	        ELSE //Frame Struct <> 1 -> ERROR
	            ;
	        END_IF;
	    END_IF;
	    (*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	    +++++++++++++++++++++++++++++++++++ interprete done ++++++++++++++++++++++++++++++++++++
	    +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*)
	END_CASE;
	
	
	//+++++++++++++++++++++++++++++++++++++++ SEND +++++++++++++++++++++++++++++++++++++
	#SENDTCON(ID := #CONNSEND_ID,
	          CONNECT := #SENDconn);
	
	#SENDTUSEND(ID := #CONNSEND_ID,
	            LEN := #SENDdata.frame_length,
	            DATA := #SENDdata,
	            ADDR := #SENDdata.remote_addr);
	
	//+++++++++++++++++++++++++++++++++++++++ RCV +++++++++++++++++++++++++++++++++++++
	#RCVTCON(ID := #CONNRCV_ID,
	         CONNECT := #RCVconn);
	
	#RCVTURCV(EN_R := true,
	          ID := #CONNRCV_ID,
	          LEN := 0,
	          RCVD_LEN => #RCVdata.frame_length,
	          DATA := #RCVdata,
	          ADDR := #RCVdata.remote_addr);
	
	
	
	
END_FUNCTION_BLOCK

DATA_BLOCK "iCPS_DB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
NON_RETAIN
"iCPS"

BEGIN

END_DATA_BLOCK

